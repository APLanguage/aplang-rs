program        → (macro_annotation+ "\n\n")? declaration* EOF ;

declaration    → class_decl | fun_decl | var_decl ;

visibility     → "prot" | "pub" | "pak" ;

class_decl     → macro_annotation* visibility? "class" IDENTIFIER ( generics )?
                 (":" type ("," type)*)? "{" declaration* "}" ;
fun_decl       → macro_annotation* visibility? generics? type? function ;
var_decl       → macro_annotation* visibility? IDENTIFIER ( ":" type )? ( "=" expression )? ";" ;
use_decl       → "use" IDENTIFIER ( "." IDENTIFIER)* ("." "*")? ";" ;

statement      → for_stmt  | if_stmt | return_stmt | while_stmt | do_while | block | var_stmt | exp_stmt | loop ;
for_stmt       → "for" "(" ( var_decl | exp_stmt | ";" )? expression? ";" expression? ")" statement
               | "for" "(" IDENTIFIER ":" expression ")" statement ;
if_stmt        → "if"  "(" expression  ")" statement ( "else" statement )? ;
return_stmt    → "return" expression? ";" ;
break_stmt     → "break" expression ";" ;
while_stmt     → "while" "(" expression ")" statement ;
do_while       → "do" block "while" "(" expression ")" ";" ;
var_stmt       → "let" IDENTIFIER ( ":" type )? ( "=" expression ) ";" ;
exp_stmt       → expression ";" ;

expression     → assignment ;
assignment     → call ( "+" | "-" | "*" | "**" | "/" | "&" | "|" | "<<" | ">>" | ">>>" | "^" | "?")
                 "=" assignment | if_ns_expr ;
if_ns_expr     → logic_or "?:" expression                | if_expr       ;
if_expr        → logic_or "?"  expression ":" expression | logic_or      ;
logic_or       → logic_and   (   "||" logic_and                       )* ;
logic_and      → equality    (   "&&" equality                        )* ;
equality       → comparison  ( ( "!=" | "=="              ) comparison)* ;
comparison     → term        ( ( ">"  | ">=" | "<" | "<=" ) term      )* ;
term           → factor      ( ( "-"  | "+"               ) factor    )* ;
factor         → bit_op      ( ( "/"  | "*"  | "**"       ) bit_op    )* ;
bit_op         → unary_left  ( ( "|"  | "^"  | "&"        ) unary_left)* ;
unary_left     →               ( "!"  | "~"  ) unary_left | call  ;
// unary_right    → primary       ( "--" | "++" ) ( NUMBER | "(" expression ")" ) | call  ;
call           → primary arguments? ( "." IDENTIFIER (arguments | array_clause )* ;

primary        → LITERAL | "self" | "super" | IDENTIFIER | lambda | "(" expression ")" | block | loop ;

loop           → "loop" block ;
function       → IDENTIFIER "(" parameters? ")" block ;
parameters     → IDENTIFIER ":" type ( "," IDENTIFIER ":" type)* ;
arguments      → "(" expression ( "," expression )* ")" ;
block          → "{" (var_decl | statement)* expression? "}" ;
type           → path generics ;
path           → IDENTIFIER ( "." IDENTIFIER)* ;
generics       → "<" type? ("," type)* ">" ;
wildcard       → ("?" | IDENTIFIER) (">" | "<") type | type
lambda         → "(" IDENTIFIER? ("," IDENTIFIER)* ")" "->" expression ;
LITERAL        → "true" | "false" | NUMBER | STRING | CHAR
NUMBER         → "0"-"9" ("." "0"-"9")? ( PREFIX )

// TODO: Lambda
// TODO: Tuples
// TODO: Deconstruction
// TODO: Think about post-incr/decr
// TODO: Think about c-style fors

array_clause   → "[" expression "]" ;
macro_annotation → ("@" | "#") "[" path
                   ("(" ( IDENTIFIER ("=" LITERAL) ("," IDENTIFIER ("=" LITERAL))*
                        | IDENTIFIER ("," IDENTIFIER)* )
                    ")")? "]" ;
